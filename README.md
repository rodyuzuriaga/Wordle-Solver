# [üöÄWordle Solver:](https://wordle-solver-six.vercel.app/) Mi Aliado para Ganar en Wordle

## Descripci√≥n General
<img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="20" />Hola! soy [**Rody**](http://linkedin.com/in/rody-uzuriaga-avil%C3%A9s-6b1409263) y cre√© **Wordle Solver**, una herramienta visual y pr√°ctica que te ayuda a encontrar la mejor palabra en cada intento.

![Wordle Solver Demo](https://github.com/user-attachments/assets/f20a414b-e0d6-4167-a4a7-afeb2c9cb70e)

**Wordle Solver** es una herramienta dise√±ada para ayudar a resolver Wordle de manera r√°pida y eficiente. Se basa en un sistema de filtrado que utiliza el feedback (representado con los s√≠mbolos `_` para ‚Äúno aparece‚Äù, `?` para ‚Äúaparece pero en posici√≥n equivocada‚Äù y `+` para ‚Äúaparece en la posici√≥n correcta‚Äù) para descartar palabras y sugerir las mejores opciones. La herramienta utiliza diccionarios de palabras en distintos idiomas y longitudes, con una diferenciaci√≥n especial entre las palabras comunes (pre-filtradas y priorizadas) y las ampliadas.

> [!NOTE]
> Lee detenidamente este documento, ya que contiene informaci√≥n importante sobre el proyecto.

---

## Inspiraci√≥n
La idea surgi√≥ tras descubrir el canal [Programa con Arnau](https://www.youtube.com/@ProgramaConArnauOficial) y su m√©todo para optimizar la resoluci√≥n de Wordle. Su contenido me motiv√≥ a desarrollar una soluci√≥n propia.

---

## Objetivos
- **Filtrado Eficiente:** Utilizar un sistema basado en listas y conjuntos para descartar palabras en funci√≥n del feedback recibido.
- **Prioridad en Palabras Comunes:** Sugerir primero palabras del diccionario ‚Äúcommon‚Äù, los cuales han sido pre-filtrados por frecuencia y longitud.
- **Interfaz Intuitiva:** Proveer una experiencia visual y pr√°ctica para el usuario, con soporte multiling√ºe.

---

## Proceso de Desarrollo

### Investigaci√≥n y Selecci√≥n de Algoritmos
Explor√© varios m√©todos para encontrar la mejor estrategia para filtrar palabras:

- **Trie**:  
  Estructura eficiente para almacenar y buscar palabras.

- **B√∫squeda Binaria**:  
  Excelente para listas ordenadas; es r√°pida pero requiere un diccionario ordenado.

- **Tablas Hash (Set)**:  
  B√∫squedas r√°pidas y eliminaci√≥n de duplicados; muy pr√°ctica pero consume m√°s memoria.

> [!NOTE]
> Uso de Tablas Hash en el Proyecto
> - excluded_letters: Se utiliza un set para almacenar las letras que no deben aparecer en la palabra.
> - required_letters: Se utiliza un set para almacenar las letras que deben estar en la palabra.
> - position_constraints: Se utiliza un diccionario con sets para manejar las restricciones de posici√≥n.

**Justificaci√≥n:**  
Opt√© por **Tablas Hash (Set)** porque ofrece una b√∫squeda eficiente y r√°pida, lo que se ajusta bien a la naturaleza de Wordle.

---

## Estructura del Proyecto

```
wordle-solver/
‚îú‚îÄ‚îÄ resources/           # Diccionarios de palabras
‚îÇ   ‚îú‚îÄ‚îÄ 5_caracteres/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common_english_5.txt
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common_spanish_5.txt
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ english_5.txt
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ spanish_5.txt
‚îÇ   ‚îú‚îÄ‚îÄ common_english.txt
‚îÇ   ‚îú‚îÄ‚îÄ common_spanish.txt
‚îÇ   ‚îú‚îÄ‚îÄ english.txt
‚îÇ   ‚îî‚îÄ‚îÄ spanish.txt
‚îú‚îÄ‚îÄ static/              # Assets del frontend
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles.css
‚îÇ   ‚îî‚îÄ‚îÄ js/
‚îÇ       ‚îî‚îÄ‚îÄ script.js
‚îú‚îÄ‚îÄ templates/           # Plantillas HTML
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ app.py               # Servidor Flask
‚îú‚îÄ‚îÄ wordle_solver.py     # L√≥gica principal del algoritmo
‚îú‚îÄ‚îÄ requirements.txt     # Dependencias del proyecto
‚îú‚îÄ‚îÄ vercel.json          # Configuraci√≥n de despliegue en Vercel
‚îî‚îÄ‚îÄ LICENSE              # Licencia del proyecto
```

> [!WARNING]
> **NO BORRAR** el archivo `package.json` si decides trabajar en el frontend.

---
## Diccionarios Utilizados

- **Para palabras de 5 caracteres:**  
  - *Comunes*:  
    - `resources/5_caracteres/common_spanish_5.txt`  
    - `resources/5_caracteres/common_english_5.txt`  
  - *Ampliados*:  
    - `resources/5_caracteres/spanish_5.txt`  
    - `resources/5_caracteres/english_5.txt`

- **Para palabras de 4, 6, 7, 8, 9, 10, 11 caracteres:**  
  - *Comunes*:  
    - `resources/common_spanish.txt`  
    - `resources/common_english.txt`  
  - *Ampliados*:  
    - `resources/spanish.txt`  
    - `resources/english.txt`

Las palabras se cargan y normalizan (se eliminan acentos, excepto la √ë, y se convierten a may√∫sculas) al iniciarse el programa. Adem√°s, se eliminan duplicados usando estructuras de conjunto para asegurar que cada palabra aparezca una √∫nica vez.

---
## C√≥mo Ejecutar el Proyecto

### Requisitos Previos
Instala las dependencias con:
```bash
pip install -r requirements.txt
```

### Iniciar el Servidor
```bash
python app.py
```

### Abrir en el Navegador
Visita: `http://localhost:5000`

> [!IMPORTANT]
> Lee las gu√≠as de contribuci√≥n antes de enviar un pull request.

---

### üìå PASOS DEL PROGRAMA
1. **Selecci√≥n de idioma.**
2. **Mostrar el tablero del juego (game-dashboard).**
3. **El usuario elige:**
   - Obtener una lista de palabras sugeridas.
   - Escribir manualmente una palabra.
4. **Activar el √°rea de juego con la primera palabra.**
5. **El usuario cambia los colores seg√∫n su feedback.**
6. **Al siguiente clic en `generate-word-btn`, se activa `valid-words` y se reduce la lista seg√∫n el feedback.**

---
## M√©todo Actual

### Reglas de Feedback
- `_` (Gris): La letra **no est√° en la palabra**.
- `?` (Amarillo): La letra **est√° en la palabra, pero no en esa posici√≥n**.
- `+` (Verde): La letra **est√° en la palabra y en la posici√≥n correcta**.

### Filtros Aplicados al Ingresar una Nueva Palabra
- **Eliminar palabras no viables** seg√∫n las restricciones.
- **Actualizar las opciones sugeridas**.

### Reglas de Filtrado Seg√∫n el Feedback
- Letras **excluidas**: Las letras con `_` no deben aparecer en la palabra.
- Letras **requeridas**: Las letras con `?` o `+` deben estar en la palabra.
- Posiciones **exactas**: Las letras con `+` deben estar en la posici√≥n exacta.
- Posiciones **prohibidas**: Las letras con `?` no deben estar en esa posici√≥n.

### Procesamiento Interno del Solver
- **Inicializaci√≥n:**
  - `reset()`: Reinicia restricciones y estado del solver.
  - `process_feedback()`: Procesa el feedback y actualiza restricciones.
- **Filtrado:**
  - `filter_words()`: Filtra palabras v√°lidas seg√∫n restricciones.
  - `get_suggested_words()`: Devuelve palabras sugeridas tras el filtrado.
- **Manejo de Restricciones:**
  - `excluded_letters`: Letras que **no deben aparecer**.
  - `required_letters`: Letras que **deben aparecer**.
  - `position_constraints`: Restricciones de posici√≥n.
- **Uso de Palabras:**
  - `mark_word_as_used()`: Marca palabras como usadas para no sugerirlas nuevamente.

### Ejemplo de Aplicaci√≥n del Feedback
Para la palabra **"pato"** con feedback `_?+_`:
- `p` no est√° en la palabra (`_`).
- `a` est√° en la palabra, pero no en la segunda posici√≥n (`?`).
- `t` est√° en la posici√≥n correcta (`+`).
- `o` no est√° en la palabra (`_`).

Las palabras sugeridas ser√°n aquellas que cumplan estas condiciones.

### Mejoras Adicionales
- **Validaci√≥n de Feedback:**
  - Solo debe contener `_`, `?`, y `+`.
  - Debe coincidir en longitud con la palabra ingresada.
- **Priorizaci√≥n de Palabras Comunes:**
  - Se dar√° prioridad a palabras de los diccionarios comunes antes de usar los ampliados.


---

## Ejemplo del Algoritmo Usado (`wordle_solver.py`)

A continuaci√≥n, un fragmento comentado para que puedas entender el c√≥digo:

```python
from collections import defaultdict
import unicodedata
import random

class WordleSolver:
    def __init__(self, word_list, word_length=5):
        self.word_list = word_list
        self.word_length = word_length
        self.reset()

    def reset(self):
        """Reinicia las restricciones y el estado del solver."""
        self.excluded_letters = set()  # Letras que no est√°n en la palabra
        self.required_letters = set()  # Letras que deben estar en la palabra
        self.position_constraints = {}  # Restricciones de posici√≥n
        self.used_words = set()  # Palabras ya usadas

    def process_feedback(self, word, feedback):
        """Procesa el feedback y actualiza las restricciones."""
        if len(word) != self.word_length or len(feedback) != self.word_length:
            raise ValueError("La palabra y el feedback deben tener la misma longitud.")

        print(f"Procesando feedback para la palabra {word}: {feedback}")

        for i, (letter, symbol) in enumerate(zip(word, feedback)):
            if symbol == "_":
                # La letra no est√° en la palabra
                if letter not in self.required_letters:
                    self.excluded_letters.add(letter)
            elif symbol == "?":
                # La letra est√° en la palabra, pero no en esta posici√≥n
                self.required_letters.add(letter)
                if i not in self.position_constraints:
                    self.position_constraints[i] = set()
                self.position_constraints[i].add(letter)
            elif symbol == "+":
                # La letra est√° en la posici√≥n correcta
                self.required_letters.add(letter)
                self.position_constraints[i] = letter
            else:
                raise ValueError(f"S√≠mbolo no v√°lido: {symbol}")

        # Verificar que no haya contradicciones entre letras excluidas y requeridas
        self.excluded_letters -= self.required_letters

        # Imprimir los conjuntos de letras excluidas, requeridas y las restricciones de posici√≥n
        print(f"Letras excluidas (no deber√≠an estar en ninguna posici√≥n): {self.excluded_letters}")
        print(f"Letras requeridas (deben estar en alguna posici√≥n): {self.required_letters}")
        print(f"Restricciones de posici√≥n: {self.position_constraints}")

    def filter_words(self):
        """Filtra las palabras v√°lidas basadas en las restricciones actuales."""
        print(f"Filtrando palabras con restricciones: {self.excluded_letters}, {self.required_letters}, {self.position_constraints}")
        
        # Imprimir el total de palabras disponibles antes del filtro
        print(f"Total palabras disponibles antes del filtro: {len(self.word_list)}")
        print("Ejemplo de palabras antes del filtro:", self.word_list[:10])  # Muestra las 10 primeras

        valid_words = []
        for word in self.word_list:
            print(f"Verificando palabra: {word}")  # Nueva l√≠nea de depuraci√≥n
            if word in self.used_words:
                continue  # Saltar palabras ya usadas

            # Verificar letras excluidas
            if any(letter in self.excluded_letters for letter in word):
                print(f"Palabra descartada por letras excluidas: {word}")  # Nueva l√≠nea de depuraci√≥n
                continue

            # Verificar letras requeridas
            if not all(letter in word for letter in self.required_letters):
                print(f"Palabra descartada por letras requeridas: {word}")  # Nueva l√≠nea de depuraci√≥n
                continue

            # Verificar restricciones de posici√≥n
            valid = True
            for i, constraint in self.position_constraints.items():
                if i >= len(word):
                    continue  # Evitar error de √≠ndice
                if isinstance(constraint, set):
                    # Restricci√≥n de posici√≥n prohibida (s√≠mbolo "?")
                    if word[i] in constraint:
                        print(f"Palabra descartada por restricci√≥n de posici√≥n prohibida: {word}")  # Nueva l√≠nea de depuraci√≥n
                        valid = False
                        break
                else:
                    # Restricci√≥n de posici√≥n exacta (s√≠mbolo "+")
                    if word[i] != constraint:
                        print(f"Palabra descartada por restricci√≥n de posici√≥n exacta: {word}")  # Nueva l√≠nea de depuraci√≥n
                        valid = False
                        break

            if valid:
                valid_words.append(word)

        # Imprimir el total de palabras despu√©s del filtro
        print(f"Total palabras despu√©s del filtro: {len(valid_words)}")
        print("Ejemplo de palabras despu√©s del filtro:", valid_words[:10])  # Muestra las 10 primeras

        print(f"Palabras sugeridas despu√©s de filtrar: {valid_words}")  # ‚úÖ Nueva l√≠nea para depuraci√≥n
        return valid_words

    def get_suggested_words(self):
        """Obtiene una lista de palabras sugeridas basadas en las restricciones."""
        valid_words = self.filter_words()
        return valid_words

    def mark_word_as_used(self, word):
        """Marca una palabra como usada."""
        self.used_words.add(word)
```

---

## Limitaciones y Trabajo Futuro
- **Rendimiento**: La b√∫squeda actual es O(n).  
- **Optimizaci√≥n**: Se planea mejorar el filtrado y uso de memoria.  
- **Futuro**: Implementar t√©cnicas de Machine Learning para mejorar la selecci√≥n de palabras.

---

### Resumen de Complejidades
| Estructura | B√∫squeda  | Inserci√≥n | Filtrado        |
|------------|-----------|-----------|-----------------|
| Trie       | O(m)      | O(m)      | O(m + k)        |
| Tabla Hash | O(1)      | O(1)      | O(n)            |
| BST        | O(log n)  | O(log n)  | O(log n + k)    |

- **m**: Longitud de la palabra.
- **n**: N√∫mero de palabras en el diccionario.
- **k**: N√∫mero de palabras v√°lidas despu√©s del filtrado.

üöÄ **Conclusi√≥n sobre Estructuras**  
- Para una base de datos de palabras grande (> 10,000), **Trie** o **Tabla Hash** son mejores.   
- Para optimizar a√∫n m√°s, se podr√≠a usar una combinaci√≥n de **Trie para indexar palabras** y **una tabla hash para acceso r√°pido a candidatos filtrados**.  

---

### *¬°Gracias por leer este documento y por considerar colaborar o dar feedback!*
